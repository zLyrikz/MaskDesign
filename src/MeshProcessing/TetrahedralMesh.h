#pragma once
#include "../MeshProcessing/TriangleMeshDistance.h"
#include "../MeshViewer/MeshDefinition.h"
#include <Eigen/Core>
#include <vector>
#include <array>
class TetrahedralMesh
{
public:
	TetrahedralMesh();
	~TetrahedralMesh();

	void SetVertex(const Eigen::MatrixX3d& _vertex);
	void SetMesh(const std::string& _mesh_file);// set mesh by read .mesh file
	void SetMesh(const Eigen::MatrixX3d& _vertex, const Eigen::MatrixX4i& _topology_tetrahedra, const Eigen::MatrixX3i& _topology_boundary);
	void SetMesh_PossibleSameTopology(const Eigen::MatrixX3d& _vertex, const Eigen::MatrixX4i& _topology_tetrahedra, const Eigen::MatrixX3i& _topology_boundary);
	void SetMeshFromInpFile(const std::string& _inp_file);// set mesh by read .inp file generated by Hypermesh for Abaqus
	void WriteMesh(const std::string& _mesh_file) const;

	void ComputeNormals();
	void ComputeSurfaceVertexNormal();
	void FindBoundaryVertex();
	void FindBoundaryTopology(const Eigen::MatrixX4i& _topology_tetrahedra, Eigen::MatrixX3i& _topology_boundary, const Eigen::MatrixX3d& _vertex) const;
	void ConstructSurfaceMesh();// construct a surface mesh respresented open mesh; need boundary vertex first (call FindBoundaryVertex())

	void Translate(const Eigen::Vector3d& _translate);
	void TranslateIndividually(const Eigen::VectorXd& _translate);// each vertex have differenct translation

	// for rendering; find which vertices to hide; hide those behind a given plane
	void InitializeRenderInformation();
	void SliceVertex(const Eigen::Vector3d& _plane_normal, const Eigen::Vector3d& _point_on_plane);


	int GetVertexNumber() const;
	void GetVertex(int _index, Eigen::Vector3d& _vertex) const;
	const Eigen::MatrixX3d* GetVertex() const;
	const Eigen::MatrixX4i* GetTopologyTetrahedra() const;
	const Eigen::MatrixX3i* GetTopologyBoundary() const;
	void GetTetrahedron(std::array<Eigen::Vector3d, 4>& _vertex, int _element_id) const;
	const std::vector<std::array<Eigen::Vector3d, 4>>* GetTetrahedraNormal() const;
	const std::vector<Eigen::Vector3d>* GetBoundaryNormal() const;
	const std::vector<Mesh::Point>* GetBoundaryVertexNormal() const;
	const std::vector<int>* GetBoundaryVertex() const;
	const std::vector<int>* GetVisibleTetrahedraId() const;
	const std::vector<int>* GetVisibleBoundaryFaceId() const;
	const std::vector<bool>* GetVisibleVertexId() const;
	void GetBoundaryMesh(Mesh& _surface_mesh) const;// NOTE!! call FindBoundaryVertex() before use

	// for setting boundary conditions
	// find the vertex behind a given plane within a vertex group
	void GetVertexBehindPlane(const Eigen::Vector3d& _plane_normal, const Eigen::Vector3d& _point_on_plane,
		const std::vector<int>& _vertex_group, std::vector<int>& _selected) const;
	void GetVertexNearMesh(const tmd::TriangleMeshDistance& _mesh_sdf,
		const std::vector<int>& _vertex_group, std::vector<int>& _selected, double _epsilon = 1e-3) const;


	void MoveVertex(int _index, const Eigen::Vector3d& _position);
	void ChangeVertex(const Eigen::VectorXd& _vertex);



private:
	Eigen::MatrixX3d vertex_;// vertex coordinates
	Eigen::MatrixX4i topology_tetrahedra_;// vertex index of each tetrahedron
	Eigen::MatrixX3i topology_boundary_;// vertex index of the boundary surface mesh; 
	// WARNING, in topology_boundary_, each triangle is repeated twice in different direction
	// e.g.
	// 5 3 2
	// 2 3 5
	// 3 1 2
	// 2 1 3
	// ...

	std::vector<std::array<Eigen::Vector3d, 4>> tetrahedra_normal_;// 4 face normal correspond to the four opposite face of the vertex
	std::vector<Eigen::Vector3d> boundary_normal_;
	std::vector<int> boundary_vertex_;// index of the boundary vertex
	std::vector<Mesh::Point> boundary_vertex_normal_;
	Mesh boundary_mesh_;

	// information for render
	std::vector<bool> is_vertex_show_;
	std::vector<int> tetrahedra_show_index_;// index of the tetrahedral whose vertices all visible
	std::vector<int> boundary_show_index_;// index of the boundary surface whose vertices all visible
};

